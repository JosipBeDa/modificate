#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use std::collections::{HashMap, HashSet};
use validify::Validate;
struct ParentWithOptionVectorOfChildren {
    #[validate]
    #[validate(length(min = 1))]
    child: Option<Vec<Child>>,
}
#[automatically_derived]
impl ::core::fmt::Debug for ParentWithOptionVectorOfChildren {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "ParentWithOptionVectorOfChildren",
            "child",
            &&self.child,
        )
    }
}
impl ::validify::Validate for ParentWithOptionVectorOfChildren {
    fn validate(&self) -> ::std::result::Result<(), ::validify::ValidationErrors> {
        let mut errors = ::validify::ValidationErrors::new();
        if let Some(child) = self.child {
            if !::validify::validate_length(
                child,
                ::std::option::Option::Some(1u64 as u64),
                ::std::option::Option::None,
                ::std::option::Option::None,
            ) {
                let mut err = ::validify::ValidationError::new_field("child", "length");
                err.add_param("min", &1u64);
                err.set_location("child");
                errors.add(err);
            }
        }
        if let Some(child) = self.child {
            for (i, item) in child.iter().enumerate() {
                if let Err(mut errs) = item.validate() {
                    errs.errors_mut()
                        .iter_mut()
                        .for_each(|err| err.set_location_idx(i, "child"));
                    errors.merge(errs);
                }
            }
        }
        if errors.is_empty() {
            ::std::result::Result::Ok(())
        } else {
            ::std::result::Result::Err(errors)
        }
    }
}
struct Child {
    #[validate(length(min = 1))]
    value: String,
}
#[automatically_derived]
impl ::core::fmt::Debug for Child {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "Child",
            "value",
            &&self.value,
        )
    }
}
impl ::validify::Validate for Child {
    fn validate(&self) -> ::std::result::Result<(), ::validify::ValidationErrors> {
        let mut errors = ::validify::ValidationErrors::new();
        if !::validify::validate_length(
            &self.value,
            ::std::option::Option::Some(1u64 as u64),
            ::std::option::Option::None,
            ::std::option::Option::None,
        ) {
            let mut err = ::validify::ValidationError::new_field("value", "length");
            err.add_param("min", &1u64);
            err.add_param("actual", &&self.value);
            err.set_location("value");
            errors.add(err);
        }
        if errors.is_empty() {
            ::std::result::Result::Ok(())
        } else {
            ::std::result::Result::Err(errors)
        }
    }
}
#[automatically_derived]
impl ::core::clone::Clone for Child {
    #[inline]
    fn clone(&self) -> Child {
        Child {
            value: ::core::clone::Clone::clone(&self.value),
        }
    }
}
#[automatically_derived]
impl ::core::hash::Hash for Child {
    #[inline]
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        ::core::hash::Hash::hash(&self.value, state)
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for Child {}
#[automatically_derived]
impl ::core::cmp::PartialEq for Child {
    #[inline]
    fn eq(&self, other: &Child) -> bool {
        self.value == other.value
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for Child {}
#[automatically_derived]
impl ::core::cmp::Eq for Child {
    #[inline]
    #[doc(hidden)]
    #[no_coverage]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<String>;
    }
}
#[rustc_main]
#[no_coverage]
pub fn main() -> () {
    extern crate test;
    test::test_main_static(&[])
}
